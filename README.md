# "glibc"-only containers

Starterkit is a distro-agnostic, vertical slice of [Linux FHS](https://refspecs.linuxfoundation.org/FHS_3.0/fhs/index.html), that contains solely a functional `glibc` and is purposefully lacking any other files stipulated by the standard.

## Why? What problem does this project solve?
It is a pragmatic way of ensuring that any binary run within said container, does not rely on any implicit dependencies (bar `glibc`) which are not provided by the binary itself. If the opposite is true, the execution simply fails, oftentimes pinpointing the dependency it was unable to make use of.

The main goal is to address the issue of ensuring [hermeticy](https://bazel.build/basics/hermeticity) of Bazel Remote Builds, done with tools which do not care for said property and which are attempting to read myriad of filesystem files during its execution (chiefly legacy corporate tools). Using “starterkit” as execution platform for such binaries, allows to greatly reduce the pains of providing the minimal dependency tree, without having to use `strace` and/or reverse engineer the binary.

## Comparison against similar projects
1. [Google distroless containers](https://github.com/GoogleContainerTools/distroless) - the images are tightly connected to Debian Linux distribution and contain the complete, expected FHS hierarchy of files. References to said files are something that `starterkit` specifically wants to prevent from taking place - if you do not care about this aspect, distroless is a project you should use.
2. [Alpine containers](https://github.com/alpinelinux/docker-alpine) - in addition to aspect mentioned for distroless project (full FHS hierarchy in container), the crated images are using `muslc` instead of traditional `glibc`. Even though compatibility shims exist, this approach makes it less appealing for situations in which full-compatibility with legacy tools is needed (as sometimes an incompatibility error might appear). If you do not care about that risk and care about minimizing the container size, this project is the one you should use.

## Base operating system

None.

Starterkit is not based upon any Linux distribution, and it obtains its `glibc` from the fantastic [Yocto Uninative project](https://docs.yoctoproject.org/gatesgarth/ref-manual/ref-classes.html#uninative-bbclass) which creates easily relocatable versions of the library.

Currently used version of uninative: **4.4 (glibc 2.38)**.

## How to...

### Use the containers?

Just like any other container image - simply pull it from the registry and run.

### Know what images are available?

<!-- Table below is autogenerated -->
| Image | Pull |
| ---   | ---  |
| ash | `harbor.apps.morrigna.rules-nix.build/explore-bzl/ash:da8k4swpfjx8m0cjrgl5fkm5q0brgg5s` |
| ash-i686 | `harbor.apps.morrigna.rules-nix.build/explore-bzl/ash-i686:ckym83jdic34a38skzcxh7ld7kk2bxlf` |
| ash-i686-cc | `harbor.apps.morrigna.rules-nix.build/explore-bzl/ash-i686-cc:4g2ny4cb11bsslm5xwhphr1c3daig7v3` |
| ash-i686-cc-x86_64 | `harbor.apps.morrigna.rules-nix.build/explore-bzl/ash-i686-cc-x86_64:pp79149hdcy6fnvxd67scp7v5lpy2h8y` |
| ash-i686-cc-x86_64-cc | `harbor.apps.morrigna.rules-nix.build/explore-bzl/ash-i686-cc-x86_64-cc:ld812848qclywxblnh12vr75xmfr9gkk` |
| ash-i686-x86_64 | `harbor.apps.morrigna.rules-nix.build/explore-bzl/ash-i686-x86_64:qjiraf20vrf25w2q660cvnshax942pag` |
| ash-i686-x86_64-cc | `harbor.apps.morrigna.rules-nix.build/explore-bzl/ash-i686-x86_64-cc:4x454vs6pk7rzgd0vlq1jidcjzlsx9b8` |
| ash-x86_64 | `harbor.apps.morrigna.rules-nix.build/explore-bzl/ash-x86_64:ddlfvpyls0xz5dxam0j9f3d2y2m6vivx` |
| ash-x86_64-cc | `harbor.apps.morrigna.rules-nix.build/explore-bzl/ash-x86_64-cc:pz7fjw1azrhsgdkldwq42w90vp85bxfh` |
| i686 | `harbor.apps.morrigna.rules-nix.build/explore-bzl/i686:6s4yh8d0r8mi1fy2vfhppjkgflwk0cmy` |
| i686-cc | `harbor.apps.morrigna.rules-nix.build/explore-bzl/i686-cc:lz8rir3glzxbcnnfrz027krqxqz1wk8n` |
| i686-cc-x86_64 | `harbor.apps.morrigna.rules-nix.build/explore-bzl/i686-cc-x86_64:68yfznk5jp0gyyy5gn86csmyi0l2fmmd` |
| i686-cc-x86_64-cc | `harbor.apps.morrigna.rules-nix.build/explore-bzl/i686-cc-x86_64-cc:hcqmnmkr76m93a3b4yia6nq6y668h0cw` |
| i686-x86_64 | `harbor.apps.morrigna.rules-nix.build/explore-bzl/i686-x86_64:rc3h4g4908xsdi2pgs50pkwdhl6kpm39` |
| i686-x86_64-cc | `harbor.apps.morrigna.rules-nix.build/explore-bzl/i686-x86_64-cc:ysc5g4605wbn2rnlx88ncdx3ac93ywpn` |
| x86_64 | `harbor.apps.morrigna.rules-nix.build/explore-bzl/x86_64:wmpyjdacgj1zql8v6bj7xbvf2xqmpgby` |
| x86_64-cc | `harbor.apps.morrigna.rules-nix.build/explore-bzl/x86_64-cc:dp8kyr1hd841h6va1a2w7pgrb497nibc` |

### Build the containers?

The images are built using [nix](https://nixos.org/explore/) but they can be used by any [OCI Certified](https://opencontainers.org/community/certified/) runtime. Nix is used solely at the build time and does not bleed into the images.

```sh
$ nix-build default.nix -A images.all
```

### Test the containers

The images are validated by running (via [bubblewrap](https://github.com/containers/bubblewrap)) two simple applications within them. Both depend on the `glibc` and one of them is [`dateutils`](https://manpages.ubuntu.com/manpages/jammy/man1/dateutils.dateutils.1.html) imported from the Ubuntu apt packages (thus ensuring compatibility with applications build with global FHS usage in mind).

```sh
$ nix-build default.nix -A images.test.all.run -o result-test-all.sh
$ ./result-test-all.sh
```

### Publish the containers?
```
$ nix-build default.nix -A images.all.push -o result-push-all.sh
$ ./result-push-all.sh <docker-registry> <username> <password>
```

### Use Starterkit as Bazel RBE platform?
1. Define the platform as follows:
    ```
    # exec_platforms/BUILD.bazel
    platform(
        name = "starterkit",
        constraint_values = [
            "@platforms//os:linux",
            "@platforms//cpu:x86_64",
        ],
        exec_properties = {
            "container-image": "docker://harbor.apps.morrigna.rules-nix.build/explore-bzl/ash-x86_64-cc:pz7fjw1azrhsgdkldwq42w90vp85bxfh",
        },
    )
    ```
2. Prepare your .bazelrc for the RBE
    ```
    # .bazelrc
    build:remote --remote_executor=grpcs://rbe.build.com
    build:remote --experimental_guard_against_concurrent_changes
    
    build:remote --strategy=remote
    build:remote --genrule_strategy=remote
    build:remote --spawn_strategy=remote
    
    build:remote --extra_execution_platforms=//exec_platforms:starterkit
    ```
3. Run the builds with `remote` config:
    ```
    bazel build //battle:showdown --config=remote
    ```

## Project origins
One of the main appeals of Bazel and its Remote Build Execution, is that it can reduce the build times of large, heterogeneous build systems from hours to seconds. To fulfill that premise, Bazel actions have to be [reproducible and hermetic](https://bazel.build/basics/hermeticity). The latter means that all of the entities involved in the build (source code, compilers but also compiler dependencies etc.) are isolated from the host system and that the state of said host does not affect the build. From a practical standpoint, it means describing all Bazel build inputs in such a way that they are placed and used from within [`Bazel execroot`](https://bazel.buil/remote/output-directories).

Said approach is not easy to achieve in practice - many tools, compilers, Bazel rules and even Bazel [itself](https://github.com/bazelbuild/bazel/blob/45dc2fc960216d1ee772f1a9c8d0c4d5524b76f4/tools/test/test-setup.sh
) (sic!) often assume that certain files will be present on the host executing given Bazel action and are reaching out of the `execroot` without a second thought (which breaks the hermeticity).

For a Bazel project that consists of a very limited amount of configurations (target / execution CPU architectures, OSes, big libraries used etc.) aforementioned approach might be an acceptable compromise, where bits of theoretical hermeticity are traded in for expediency in delivery. However, for a project of more significant size, it  will very quickly become troublesome and cause an explosion of out-of-bazel dependencies that need to be tracked and taken care of.

**Example**: For a CPP project that has to be compiled for many architectures (aarch64, amd64, mipsel, ppce64 … and more), following choices are available: (1) to have dedicated worker machines with matching architecture; (2) to use cross-compilers that are pre-installed on the hosts available for Bazel actions; (3) to use cross-compilers that are able to be used from the Bazel `execroot`. In all but that last approach, Bazel does not really govern the compilation dependencies, which makes it more difficult to compose them together and introduces a lot of additional bookkeeping that has to take place outside of the Bazel dependency graph.

This project is the result of suffering through process of making aforementioned toolchains, compilers, cross-compilers and more, relocatable under `execroot` and having their dependencies fully described so that the Bazel RBE may easily compose an action environment for all of its needs.

As it is not always practical or possible, to trace all dependencies of a given tool/compiler/Bazel rule/etc. upfront, starterkit makes it dead simple to ensure that a build is truly not depending on anything else but the bare `glibc` - by the means of stripping everything else. Said approach provides both a minimal execution environment for Bazel RBE and does ensure that nothing besides `glibc` is used.

The cut-off point has been chosen at the `glibc` level, as in the authors experience, there is a significant amount of binaries that will need a non-trivial amount of work to be used without it. Therefore it is a compromise between attempts to make Bazel builds truly hermetic and the limitations of prevalent applications.
